### 1 为什么只能在`ORDER BY`中使用别名,其他关键字的子句中无法使用别名?

### 2 为什么`ORDER BY`不能位于`WHERE`之前?

### 3 为什么`LIMIT`不能位于`ORDER BY`之前?

### 4 从`SELECT`语句的执行顺序来解释我们的聚合函数的特性

> **特性**
>
> - `GROUP BY`不能用在``WHERE``之前
> - `WHERE`子句中不能使用聚合函数
> - `GROUP BY`中指定的字段可以不是我们查询的字段

### 5 `COUNT(*)`与`COUNT(列名)`与`COUNT(1)`与`COUNT(Expression)`的区别

- `COUNT(*)`:该操作会直接统计我们查询得到的**最终虚拟数据表**中的记录的个数
- `COUNT(列名)`:该操作会统计我们查询得到的**最终虚拟数据表**中的对应字段**不为`NULL`的记录的个数**
- `COUNT(1)`:该操作效果等同于`COUNT(*)`
- `COUNT(2)`:该效果等同于`COUNT(*)*2`
- `COUNT(n)`:该效果等同于`COUNT(*)*n`
- `COUNT(字段1>50)`:该操作会统计我们查询得到的**最终虚拟数据表**中**字段$$1$$取值大于$$50$$**的记录的个数
- `COUNT(字段1>50 AND 字段2 <30)`:该操作会统计我们查询得到的**最终虚拟数据表**中**字段$$1$$取值大于$$50$$且字段$$2$$取值小于30**的记录的个数

### 6 在一个`SELECT`查询中`GROUP BY`不能出现在`WHERE`之前,那么如何对`GROUP BY`得到的数据进行过滤呢?

> 对``GROUP BY``后的虚拟数据表进行记录的过滤操作是借助`HAVING`关键字来进行的,当然其实我们还可以借助**子查询**的方式使用``WHERE``来完成这个过滤过程.

### 7 `MySQL`中`WHERE`与`HAVING`的不同

> 两者都是用于按条件过滤的,并且对于单表查询而言,两者底层十分相似,但是由于`SELECT`执行顺序问题导致了他们的一些不同.其区别有以下两个
>
> - ==**不同点1**==:`WHERE`由于`MySQL`的底层实现,其是一个用于遍历每一条记录的过滤条件,无法获得大于一条以上的记录的信息,因此`WHERE`子句中是**无法使用任何涉及到多个记录的同时操作的行为的**.而`HAVING`是必须与`GROUP BY`配合并紧跟`GROUP BY`语句的因此`HAVING`子句中**既可以使用单记录行为又可以使用多记录行为**
> - ==**不同点2**==:对于**关联查询**问题`WHERE`子句是先筛选再连接,而`HAVING`则是先连接再筛选,因此`WHERE`子句在关联查询上**性能优于**`HAVING`子句.**因此当我们使用到关联查询时,可以考虑通过子查询的方式将`HAVING`实现替换为`WHERE`实现以提高性能**
> - ==**补充**==:`HAVING`的过滤粒度为**分组**,而`WHERE`的过滤粒度为**记录**
>   - **过滤粒度为分组**:即其筛选的是以分组为单位的,如果对应的分组不符合`HAVING`子句筛选条件,或该分组中存在记录不符合`HAVING`子句筛选条件,那么其对应的那整个分组都会被剔除
>   - **过滤粒度为记录**:即其筛选是以记录为单位的,如果对应的记录不符合筛选条件,那么就会将该记录剔除

### ==**8 `MySQL`的`SELECT`语句的关键字的先后排列顺序的规定**==

> **注意**:这些都**只是我们用于编写`SQL`语句时遵循的顺序逻辑**,**实际上我们的`MySQL`会根据我们写出的`SQL`语句以最高效的顺序执行**.但**可以保证**的是,按**照下面的规则推导出来的理论结果与`MySQL`最终查询出来的结果不会有区别**,只不过如果**按照我们下面的顺序执行**,那么**效率会极低**

#### 单表查询

#### 多表查询

#### **内连接**

```SQL
SELECT DISTINCT Table1.字段1,Table2.字段2
FROM Tabel1 
JOIN Table2
ON 连接条件
WHERE((过滤条件1 AND 过滤条件2) OR (NOT 过滤条件3)) 
GROUP BY Table1.字段3
HAVING 过滤条件
ORDER BY Table1.字段1 DESC
LIMIT 分页设置
```

##### 执行顺序

1. 执行两个表的内连接操作`JOIN`,得到两个表笛卡尔积后的**虚拟数据表1**
2. 对**虚拟数据表1**按照`ON`子句进行连接筛选,得到**虚拟数据表2**
3. 对**虚拟数据表2**执行`WHERE`子句指示的过滤操作(==过滤粒度为记录==)得到过滤后的**虚拟数据表3**
4. 对**虚拟数据表3**按照`GROUP BY`子句进行分组操作,得到**虚拟数据表4**
5. 对**虚拟数据表4**按照`HAVING`子句进行过滤操作(==过滤粒度为分组==),得到**虚拟数据表5**
6. 对**虚拟数据表5**按照`ORDER BY`子句进行排序操作,得到**虚拟数据表6**
7. 对**虚拟数据表6**进行`SELECT`子句查询操作,得到**虚拟数据表7**
8. 对**虚拟数据表7**进行`DISTINCT`去重操作,得到**虚拟数据表8**
9. 对**虚拟数据表8**进行`LIMIT`子句分页管理操作,得到**最终虚拟数据表9**
10. 将**虚拟数据表9**返回给用户

#### 外连接

```sql
SELECT Table1.字段1,Table2.字段2
FROM Tabel1 
LEFT JOIN Table2
ON 连接条件
WHERE((过滤条件1 AND 过滤条件2) OR (NOT 过滤条件3)) 
GROUP BY Table1.字段3
HAVING 过滤条件
ORDER BY Table1.字段1 DESC
LIMIT 分页设置
```

##### 执行顺序

1. 执行两个表的内连接操作`JOIN`,得到两个表笛卡尔积后的**虚拟数据表1**
2. 对**虚拟数据表1**按照`ON`子句进行连接筛选,得到**虚拟数据表2**
3. 对**虚拟数据表2**进行左表填充操作,得到**虚拟数据表3**
4. 对**虚拟数据表3**执行`WHERE`子句指示的过滤操作(==过滤粒度为记录==)得到过滤后的**虚拟数据表4**
5. 对**虚拟数据表4**按照`GROUP BY`子句进行分组操作,得到**虚拟数据表5**
6. 对**虚拟数据表5**按照`HAVING`子句进行过滤操作(==过滤粒度为分组==),得到**虚拟数据表6**
7. 对**虚拟数据表6**按照`ORDER BY`子句进行排序操作,得到**虚拟数据表7**
8. 对**虚拟数据表7**进行`SELECT`子句查询操作,得到**虚拟数据表8**
9. 对**虚拟数据表8**进行`DISTINCT`去重操作,得到**虚拟数据表9**
10. 对**虚拟数据表9**进行`LIMIT`子句分页管理操作,得到**最终虚拟数据表10**
11. 将**虚拟数据表10**返回给用户

### 9 虚拟数据表结构剖析

#### 内连接

- **虚拟数据表1**`[m×n]×[s×t]`，该表由两个表的记录的笛卡尔积形成，若第一个表为$$m$$条记录,第二个表为$$n$$条记录,那么**虚拟数据表1**的记录数为==$m×n$==条.若第一个表有$$s$$个字段,第二个表有$t$个字段,那么**虚拟数据表1**的每一条记录都有==$s×t$==个字段
- **虚拟数据表2**`{小于等于[m×n]}×[s×t]`,我们知道虚拟数据表共有$m×n$条$s×t$个字段的记录,我们的`MySQL`服务系统会按照`ON`子句对这$m×n$条记录进行过滤,并将符合条件的记录作为**虚拟数据表2**的记录.因此**虚拟数据表2**的记录数一定小于等于$$m×n$$,其记录的字段数一定等于$s×t$
- **虚拟数据表3**,`{小于等于[m×n]}×[s×t]`,`MySQL`服务系统会对**虚拟数据表2**的每一条记录按照`WHERE`子句进行过滤,符合条件的记录会被作为**虚拟数据表3**的记录.因此**虚拟数据表3**的记录数一定小于等于**虚拟数据表2**
- **虚拟数据表4**,`p×[{小于等于[m×n]}×[s×t]]`,`MySQL`服务系统会对**虚拟数据表3**按照`GROUP BY`子句指定的字段进行分组,我们可以理解为将**虚拟数据表3**分组拆分成`p`个子表,然后由这`p`个子表按一定顺序组成我们的**虚拟数据表4**
- **虚拟数据表5**,`{小于等于[m×n]}×[s×t]`,`MySQL`服务系统会对**虚拟数据表4**按照`HAVING`子句对其`p`个子表进行过滤操作,不符合条件的子表会被整体剔除,而符合条件的子表则会用于组成**虚拟数据表5**
- **虚拟数据表6**,`与虚拟数据表5等大小`,`MySQL`服务系统会对虚拟数据表的记录按照我们`ORDER BY`子句指定的方式来进行排序,得到**虚拟数据表6**
- **虚拟数据表7**,`{小于等于[m×n]}×[s×t]`,`MySQL`服务系统会按照`DISTINCT`语句指定的去重方式,对**虚拟数据表6**进行整体遍历,找到重复的记录,并将重复的记录按照一定的规则删除掉,只留下其中一条.
- **虚拟数据表8**,`与虚拟数据表7相等×SELECT语句指定的字段数`,`MySQL`服务系统会**虚拟数据表7**的所有记录中的没有出现在`SELECT`子句中的字段去除,然后将剔除完成后的所有记录汇总形成我们的**虚拟数据表8**也即**最终输出数据表**

#### 外连接

> **外连接的大部分虚拟数据表类似于内连接,只不过在``JOIN``子句操作时有所不同**

##### 左连接

- `JOIN`子句首先用两个数据表的记录的笛卡尔积组成$[m×n]×[s×t]$的**虚拟数据表a**,然后按照`ON`子句给出的条件对该**虚拟数据表a**进行过滤,用符合条件的记录组成一个**虚拟数据表b**.然后会将左表中的没有在**虚拟数据表b**中出现的每一个记录扩展为$s×t$个字段,其中前$s$个字段**为第一个数据表中的字段**,其**有实际取值**.后$t$个字段为**第二个数据表中的字段**,其**取值全为空**.

##### 右连接

- `JOIN`子句首先用**两个数据表的记录的笛卡尔积**组成$[m×n]×[s×t]$的**虚拟数据表a**,然后按照`ON`子句给出的条件对该**虚拟数据表a**进行过滤,用符合条件的记录组成一个**虚拟数据表b**.然后会将右表中的没有在**虚拟数据表b**中出现的每一个记录扩展为$s×t$个字段,其中前$s$个字段为第一个数据表中的字段,其**取值全为空**.后$t$个字段**为第二个数据表中的字段**,其**有实际取值**.

### 10 当涉及到窗口函数时的`SELECT`语句执行流程

> - 实际上窗口函数的执行时机是在我们的查询操作得到了最终的**虚拟数据表**,并要对该**虚拟数据表**根据`SELECT`子句进行字段抽取的时候.
> - 标准形式:`函数 OVER([PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC])`
> - 下面我们以`SELECT 带窗口函数的字段1 AS 别名1,带窗口函数的字段2 AS 别名2,不带窗口函数的字段3 AS 别名3`

#### 案例

```mysql
CREATE TABLE goods(
id INT PRIMARY KEY AUTO_INCREMENT,
category_id INT,
category VARCHAR(15),
NAME VARCHAR(30),
price DECIMAL(10,2),
stock INT,
upper_time DATETIME
);

INSERT INTO goods(category_id,category,NAME,price,stock,upper_time)
VALUES
(1, '女装/女士精品', 'T恤', 39.90, 1000, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '连衣裙', 79.90, 2500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '卫衣', 89.90, 1500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '牛仔裤', 89.90, 3500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '百褶裙', 29.90, 500, '2020-11-10 00:00:00'),
(1, '女装/女士精品', '呢绒外套', 399.90, 1200, '2020-11-10 00:00:00'),
(2, '户外运动', '自行车', 399.90, 1000, '2020-11-10 00:00:00'),
(2, '户外运动', '山地自行车', 1399.90, 2500, '2020-11-10 00:00:00'),
(2, '户外运动', '登山杖', 59.90, 1500, '2020-11-10 00:00:00'),
(2, '户外运动', '骑行装备', 399.90, 3500, '2020-11-10 00:00:00'),
(2, '户外运动', '运动外套', 799.90, 500, '2020-11-10 00:00:00'),
(2, '户外运动', '滑板', 499.90, 1200, '2020-11-10 00:00:00');

SELECT 

ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num1,
#ROW_NUMBER() OVER(PARTITION BY stock ORDER BY price DESC) AS row_num2,
id, category_id, category, `NAME`, price, stock

FROM goods;

SELECT 

#ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num1,
ROW_NUMBER() OVER(PARTITION BY stock ORDER BY price DESC) AS row_num2,
id, category_id, category, `NAME`, price, stock

FROM goods;

SELECT 

ROW_NUMBER() OVER(PARTITION BY category_id ORDER BY price DESC) AS row_num1,
ROW_NUMBER() OVER(PARTITION BY stock ORDER BY price DESC) AS row_num2,
id, category_id, category, `NAME`, price, stock

FROM goods;
```

- <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220706180033294.png" alt="image-20220706180033294" style="zoom:80%;" />
- <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220706180125399.png" alt="image-20220706180125399" style="zoom:80%;" />
- <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220706173159863.png" alt="image-20220706173159863" style="zoom:70%;" />

#### 基本流程

- 首先`MySQL`服务系统将`SELECT`子句需要使用到的字段提取出来组成一张新的**虚拟数据表A**.
  - **注意**:此时该虚拟数据表的有两列的所有值都为空(因为这两个字段`row_num1`,`row_num2`涉及到窗口函数,需要经过一些步骤才能获得其值,而无法直接读取原虚拟数据表获取),其他的列则由于就是`最终虚拟数据表`中字段,因此直接按照字段名向`最终虚拟数据表`中提取即可得到.
- **`row_num1`的计算**
  - 对**虚拟数据表A**按照第一个窗口函数子句的`PARTITION BY`子句进行分组,并以分组为单位组成新的**虚拟数据表B**
    - **注意**:在`PARTITION BY`的分组组合阶段**各个分组并不是随便组合**的,而是根据**一开始`PARTITION BY`指定的用于分组的字段越小的分组的排位越靠前**,也即我们的`PARTITION BY`**自带一个分组粒度的排序操作**
  - 对**虚拟数据表B**按照第一个窗口函数子句的`ORDER BY`子句进行各个分组内的排序.各个分组之间不会产生影响.排序只作用与分组内部.将各个排序好的分组再次组合起来生产**虚拟数据表C**
  - 根据**虚拟数据表C以分组为单位**对我们的`row_num1`字段的值进行计算,并将计算结果一一对应地填入**虚拟数据表C**,我们称`row_num1`字段被计算并填写好后的表为**虚拟数据表D**
- **`row_num2`的计算**
  - 对**虚拟数据表D**按照第二个窗口函数子句的`PARTITION BY`子句进行分组,并以分组为单位组成新的**虚拟数据表E**
    - **注意**:在`PARTITION BY`的分组组合阶段**各个分组并不是随便组合**的,而是根据**一开始`PARTITION BY`指定的用于分组的字段越小的分组的排位越靠前**,也即我们的`PARTITION BY`**自带一个分组粒度的排序操作**
  - 对**虚拟数据表E**按照第二个窗口函数子句的`ORDER BY`子句进行各个分组内的排序.各个分组之间不会产生影响.排序只作用与分组内部.将各个排序好的分组再次组合起来生产**虚拟数据表F**
  - 根据**虚拟数据表F以分组为单位**对我们的`row_num2`字段的值进行计算,并将计算结果一一对应地填入**虚拟数据表F**,我们称`row_num2`字段被计算并填写好后的表为**虚拟数据表G**
- 到这一步所有的窗口函数字段`row_num1`,`row_num2`都被计算好了,并存储在**虚拟数据表G**中
- 将**虚拟数据表G**不需要向用户呈现的字段(列)剔除,并将剩下待呈现的字段按照用户在`SELECT`子句中指定的先后顺序排列好,得到最终的**虚拟数据表H**
- 将**虚拟数据表H**的结果返回给我们的用户

#### 讨论

> **我们从前面可以发现以下几个窗口函数的特点**
>
> - **一个**`SELECT`**查询语句**中**可以使用多个窗口函数**
> - 每一个**窗口函数使用的窗口**可以**相同**也**可以不相同**
> - 由于窗口函数可能涉及到`PARTITION BY`分组以及`ORDER BY`排序,因此当**使用到多个窗口函数**,且这些窗口函数**使用了两个及以上的不同的窗口**时,我们的**最终结果**就需要**根据**我们上面的**案例解释的原理**进行**推理得出**.而**没有**一个**很好的规则**可以**直接概括**.
> - 各个涉及窗口函数**在底层被计算出来的先后**完全由其在`SELECT`子句中排序的先后决定(**在左边的总比在右边的先被算得**)
>   - **如**:我们上面的案例中就是**先**计算得到`row_num1`**再**计算得到`row_num2`
> - **注意**:在`PARTITION BY`的分组组合阶段**各个分组并不是随便组合**的,而是根据**一开始`PARTITION BY`指定的用于分组的字段越小的分组的排位越靠前**,也即我们的`PARTITION BY`**自带一个分组粒度的排序操作**
> - **窗口函数的计算是以分组为单位的**,一个分组下的窗口函数的计算过程**只会用到该分组下的记录**,而不**会用到任何其他分组下的记录的任何一点信息**,我们又称这为**分组隔离**特性

### 11 `MySQL`的`SELECT`语句的关键字对应的操作的执行顺序

```sql
SELECT Table1.字段1,Table2.字段2					 %⑦  
FROM Tabel1 	  									%①
LEFT JOIN Table2  									%①
ON 连接条件		   									 %②
WHERE((过滤条件1 AND 过滤条件2) OR (NOT 过滤条件3))    %③
GROUP BY Table1.字段3								   %④
HAVING 过滤条件										 %⑤
ORDER BY Table1.字段1 DESC						   %⑥
LIMIT 分页设置										  %⑧
```

### 12 `MySQL`的`SELECT`语句的执行原理

`JOIN ON`子句

```python
虚拟数据表=[]
for 记录1 in Table1:
	for 记录2 in Table2:
		合并记录 = [记录1,记录2]
		if 合并记录 符合 ON子句:
			虚拟数据表.append(合并记录)
```

`LEFT JOIN ON`子句

```python
虚拟数据表=[]
for 记录1 in Table1:
	for 记录2 in Table2:
		合并记录 = [记录1,记录2]
		if 合并记录 符合 ON子句:
			虚拟数据表.append(合并记录)
			Table1.Delete(记录1)
for 记录 in Table1:
	虚拟数据表.append(记录)
```

`WHERE`子句

```python
虚拟数据表=[]
for 记录 in Table:
	if 记录 符合 WHERE子句
		虚拟数据表.append(记录)
```

`GROUP BY`子句

```

```

`HAVING`子句

```python
虚拟数据表=[]
for 分组 in Table:
	if 分组 符合 HAVING子句
		虚拟数据表.append(分组)
```

`ORDER BY`子句

`SELECT`子句

`DISTINCT`子句

`LIMIT`子句

### 13 如何对`GROUP BY`分组以粒度为记录进行过滤?

> **问题**:如果我们想分别筛选并剔除各个分组中一些不符合某种条件的记录,只保留各个分组中符合条件的记录.由于`HAVING`筛选的粒度是以**分组**为单位的,那么我们应该如何对`GROUP BY`分组实现这样的**记录粒度**的筛选呢?

### ==**14 涉及子查询的`SELECT`语句的执行顺序**==

- `FROM`子句中写子查询
- `JOIN|LEFT JOIN|FULL JOIN|RIGHT JOIN`子句中写子查询
- `WHERE`子句中写子查询
- `HAVING`子句中写子查询
- `ORDER BY`子句中写子查询

### ==**15 `ORDER BY`排序的运行原理剖析**==

- 首先`ORDER BY`子句会拿到我们的**虚拟数据表a**,然后**对该表的每一条记录进行遍历**并按照`ORDER BY`子句的表达式**计算出每一个记录的值,形成一个`记录:值`的特殊列表**,然后**对该特殊列表按照值进行排序**(`DESC|ASC`)然后**根据我们列表的顺序获取到虚拟数据表a各个记录的顺序**,将各个记录按照顺序排列好后组成**虚拟数据表b**作为`ORDER BY`子句的**输出**

### ==**16 多表连接的补齐问题**==

### 17 `IN`与`NOT IN`的奇怪案例分析(空值问题)

> **问题描述**:
>
> - 考虑这样一个问题``'abc' IN (NULL,'abc','bca','sss')``,原则上其返回应该是`TRUE`,但是由于后面的列表中有一个``NULL``元素,因此当在遍历比较时`'abc'=NULL`的结果为`NULL`,因此其实际的输出为`NULL`
>
> - 同样的`'abc' NOT IN (NULL,'abc','bca','sss')`,原则上其返回应该是`FALSE`,但是同样的原因,其返回依然会是`NULL`
>
> **问题后果**:
>
> - 由于`WHERE或HAVING`子句只有在返回为`TRUE`是才认为对应记录是符合条件的记录,而对于返回为`NULL`或`FALSE`的记录其都会认为是不符合条件的记录.因此上面的第一个问题中即便从我们看来该表达式对应的记录应该是符合条件的,但是实际上该记录会被认为是不符合条件的
> - 并且在列表中`NULL`不去除的情况下啊,无论左边是什么字符串,什么数值,最后的返回都只会是`NULL`

```SQL
#方式1 错误结果
SELECT d1.department_id,d1.department_name
FROM departments as d1
WHERE d1.department_id NOT IN (
							   SELECT DISTINCT department_id
    						   FROM employees
							  );
#方式1  正确结果							  
SELECT d1.department_id,d1.department_name
FROM departments as d1
WHERE d1.department_id NOT IN (
							   SELECT DISTINCT department_id
    						   FROM employees
									 WHERE department_id  IS NOT NULL
							  );
```

### ==**18 当空值遇到涉及子查询的表连接**==

> **问题描述**:

```SQL
#查询employees表中所有员工的employee_id和salary,并按照他们所属的department_name进行排序

#SQL92  有一点小问题
SELECT e1.employee_id,e1.salary 
FROM employees as e1,(SELECT department_name,department_id
         			  FROM employees as e2,departments as d1
         			  WHERE e2.department_id <=> d1.department_id ) as s1
WHERE e1.department_id <=> s1.department_id
ORDER BY s1.department_name;
#改进并正确解决了问题
SELECT e1.employee_id,e1.salary 
FROM employees as e1,(SELECT department_name,department_id
         			  FROM employees as e2,departments as d1
         			  WHERE e2.department_id <=> d1.department_id ) as s1
WHERE e1.department_id <=> s1.department_id(+)
ORDER BY s1.department_name;

#SQL99  有一点小问题
SELECT DISTINCT employee_id,salary 
FROM employees as e1 JOIN (
    					   SELECT d1.department_name,d1.department_id
         			  	   FROM employees as e2,departments as d1
         			  	   WHERE e2.department_id <=> d1.department_id
						  ) as s1
ON e1.department_id <=> s1.department_id
ORDER BY s1.department_name;
#改进并正确解决了问题
SELECT DISTINCT employee_id,salary 
FROM employees as e1 LEFT JOIN (
    					   SELECT d1.department_name,d1.department_id
         			  	   FROM employees as e2,departments as d1
         			  	   WHERE e2.department_id <=> d1.department_id
						  ) as s1
ON e1.department_id <=> s1.department_id
ORDER BY s1.department_name;

#方式3  正确解决了问题
SELECT e1.employee_id,e1.salary
FROM employees as e1
ORDER BY (SELECT department_name
          FROM departments as d1
          WHERE d1.department_id=e1.department_id);
```

### ==**19 学会使用下面的图来分析当前的状态与问题的解决办法**==

> **问题17**就是由于没有仔细从下图的集合关系角度来分析问题状态导致了最终结果相比于正确结果少了一条记录

- **问题**:

<img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\基础知识汇总_Windows.assets\image-20220630211243062.png" alt="image-20220630211243062" style="zoom: 85%;" />

### 20 `MySQL`使用双引号`""`与着重号**``**来解决一些问题

#### 双引号`""`

- 当我们在给字段起别名时需要使用到空格时,我们就可以使用`"别名"`的方式用双引号将别名包裹起来

#### 着重号`''`

- 当我们的字段名,变量名等与`MySQL`关键字重名时,我们就可以用着重号将他们包括起来

### ==**21 `COMMIT`与`ROLLBACK`背后的内存与磁盘交互问题**==

#### `COMMIT`

> 提交数据。一旦`COMMIT`指令被执行,所有的数据就会被永久地保存到数据库中,此时该数据便不再可回滚
>
> - 例如我们修改了数据表中的某一个记录的某个字段的值.
>   - 在**修改完成之后**,**`COMMIT`指令执行之前**,磁盘中该记录依然为未修改前的记录,而内存中的该记录则是修改后的.
>   - **当`COMMIT`指令执行之后**,内存中的修改后的记录就会保存到磁盘上,而原本未修改的记录就会被覆盖.到这一步,我们便无法通过任何办法获取到修改前的记录.

#### `ROLLBACK`

> 回滚数据。一旦`ROLLBACK`指令被执行,那么数据库就会回到最近的一次`COMMIT`指令之后的状态
>
> - 我们可以这样理解`ROLLBACK`指令.
> - 我们的`MySQL`会把磁盘中保存的数据库读取到内存中来供应我们操作,因此我们操作的是内存上的数据库,而不是磁盘上的数据库.
> - 磁盘上的数据库与内存上的数据库是不同步的.而`COMMIT`指令就是用于将内存中的数据库,覆盖到磁盘上的.
> - 而我们的`ROLLBACK`则可以理解为,当前我们内存上的数据库发生了错误,我们首先会把内存上的数据库删除掉,然后我们会读取磁盘中的数据库到内存中.然后我们来操作内存上的数据库.
> - 这也就解释了为什么`ROLLBACK`只能回滚到最近的一次`COMMIT`之后(因为磁盘中保存到数据库一定是最后一次`COMMIT`之后的数据) 

### 22 `TRUNCATE TABLE`与`DELETE FROM`在清空表数据上的区别

- `TRUNCATE TABLE`:该指令**包含有隐式的`COMMIT`调用**,因此该指令清空表后会自动执行`COMMIT`指令.因此如果我们**用该指令清空表**,那么是**无法回滚被清空的数据的**
- `DELETE FROM`:该指令**不包含隐式的`COMMIT`调用**,因此如果使用该指令来删除或清空表数据,是不会自动执行`COMMIT`指令的.因此如果我们**使用该指令删除或清空表**,那么是**可以回滚被删除或清空的数据的**

### 23 `DDL`与`DML`在可回滚性上的区别

> `DDL`:`DDL`的指令**一旦执行**,那么就**不可回滚**.其原因在于任何一个`DDL`指令在执行完之后都会自动执行`COMMIT`指令.
>
> `DML`:`DML`指令在**默认情况**下,**一旦执行**,那么就**不可回滚**(即默认情况下会自动执行`COMMIT`指令).但是我们可以通过`SET autocommit =FALSE`,那么`DML`指令此时执行之后是**可以回滚的**(因为此时系统不会自动执行`COMMIT`指令),但是此时**需要我们自己在合适的时机调用`COMMIT`指令**

### ==24 `DDL`,`DML`,`DCL`==

#### `DDL`

- `CREATE`
- `DROP`
- `ALTER ADD`
- `ALTER MODIFY`
- `ALTER RENAME TO`
- `SHOW`
- `USE`
- `SOURCE`
- `TRUNCATE`
- `DESCRIBE`

#### `DML`

- `INSERT`
- `DELETE FROM WHERE`
- `UPDATE SET WHERE`
- `SELECT FROM`

#### `DCL`

- 

### 25`DDL`的原子化

> 例如`DROP TABLE <表1>,<表2>`的操作.其作用为删除两个表.我们现在假设`<表1>`可以成功删除而``<表2>``不可成功删除

#### `MySQL 5.7`

> 在`MySQL 5.7`中并不支持`DDL`的原子化,因此对于上面的情况就会出现原来的命令变成与`DROP TABLE <表1>`等效的命令

#### `MySQL 8.0`

> 在`MySQL 8.0`中是支持`DDL`原子化的,因此对于上面的情况会在上面的语句执行完毕后马上自动执行``ROLLBACK``指令

### ==**26 使用`CHARACTER SET 字符集名`指定字符集**==

- **指定数据库字符集**

  ```SQL
  CREATE DATABASE <数据库名> CHARACTER SET utf8mb4
  ```

- **指定数据表字符集**

  ```SQL
  CREATE TABLE <表名>() CHARACTER SET utf8mb4
  ```

- **指定字段字符集**

  ```SQL
  CREATE TABLE <表名>(字段1 VARTEXT(15) CHARACTER SET utf8mb4)
  ```

- **问题**:下述的语句的结果中各个字段的字符集会是什么情况?

  > `MySQL`中字符集是向上兼容的
  >
  > - 如果字段没有指定字符集,那么就会使用其所属的表使用的字符集
  > - 如果表没有指定字符集,那么就会使用其所属的数据库所使用的字符集
  > - 如果库没有指定字符集,那么就会使用`DBMS`的默认字符集
  > - **注意:所谓向上兼容即,如果字符指定了字符集,那么其所属表使用什么字符集是不会对其产生影响的.同样数据表与数据库之间,数据库与`DBMS`之间也是同样的**

  ```SQL
  CREATE TABLE <表名>(
  字段1 VARTEXT(15) CHARACTER SET utf8mb4,
  字段2 VARTEXT(15) CHARACTER SET utf8
  ) CHARACTER SET gbk2312;
  ```

### 27 `float,double`浮点数在计算机中的存储方式

> 在计算机中浮点数的存储被划分为三个部分
>
> - `符号`
> - `底数`
> - `阶数`
>
> **`float`与`double`**的不同就体现在他们呢所占据的**字节数的不同,底数占据的`bit`数不同,阶数占据的`bit`数不同**上
>
> - `float`
>   - `4`字节,``32bit`
>   - 

### 28 无符号的浮点数

> 由于计算机中浮点数的存储结构中是固定有一个``bit``用于保存符号.因此**无符号的浮点数并不会拥有更大的取值范围**,其**取值范围反而**变成了只是原本取值范围的非负数部分(**也即取值范围缩小**)

### 29 `MySQL`浮点数的`REAL`类型

### 30 `MySQL`中数据超出字段规定的取值范围会发生什么?

> - **不同**于`C语言`,`Python`等语言的当**取值超出范围会发生循环的操作**.
> - 在`MySQL`中如果我们存入数据时**数据大取值超出了范围**,那么就会**违背``域完整性``**从而**直接报错**,**并且该超范围的数据不会被存入.**

### 31 二进制下的小于1的数保存与整数的保存

#### 二进制小数表示

- 小数转二进制数(**以0.3转二进制小数为例**)
  $$
  0.3×2=0.6\quad取整数位为0\\
  0.6×2=1.2\quad取整数位为1\\
  0.2×2=0.4\quad取整数位为0\\
  0.4×2=0.8\quad取整数位为0\\
  0.8×2=1.6\quad取整数位为1\\
  由此0.4的二进制小数表示为.0\dot1\dot0\dot0\dot1
  $$

- 二进制小数转十进制小数(**以0.3的二进制小数$.0\dot 1\dot 0\dot 0\dot 1$为例**)
  $$
  0×2^{-1}+1×2^{-2}+0×2^{-3}+0×2^{-4}+1×2^{-5}+\cdots
  $$

### 32 `TIMESTAMP`的底层保存原理以及其时区转换呈现原理

### 33 `JSON`数据类型的多种查询操作

### 34 `DECIMAL`数据类型的存储原理与运算原理

### 35 `TEXT`类型与`CHAR或VARCHAR`类型的选取

### 36 `CHAR`类型与`VARCHAR`类型的选取

<img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\基础知识汇总_Windows.assets\image-20220702213829016.png" alt="image-20220702213829016" style="zoom:89%;" />

### 37 `TIMESTAMP`类型与`DATETIME`类型的选取

### 38 浮点数类型与第定点数类型`DECIMAL`的选取

### 39 英文字母,拉丁字母,中文汉字等占据的内存空间分析

> **前提**:在不同的字符集中字符的编码方式不同

- `latin`:每一个字符只使用`1Bytes`进行存储,因此`Latin`字符集**无法保存中文**
- `gbk`:每个字符使用`2Bytes`表示,是``GB2312``的扩展，加入对**繁体字**的支持，兼容``GB2312``
- `utf8`:采用变长字节 (``1Bytes`` ASCII, `2Bytes` 希腊字母, `3Bytes` 汉字, `4Bytes` 平面符号) 表示
- `utf16`:采用`2Bytes`
- `utf32`:采用`4Bytes`
- `utf8mb3`:在`utf8`基础上限制任意单字符字节数都为``3Byte``,即**不再是变长编码,**而是**定长编码**
- `utf8mb4`:在`utf8`基础上限制任意单字符字节数都为``4Byte``,即**不再是变长编码**,而是**定长编码**

### 40 为什么`VARCHAR`,`TEXT`等数据类型存储`M`个字符要用`M+N`个字节?

> **前提**:使用`utf8mb4`字符集

#### 为什么会要`+N`?

> 由于这些类型都是变成类型,不同的记录的该字段都不一定占据相同的存储空间,**因此需要占用一定的存储空间来对其占用存储空间大小进行存储**.因此需要`+N`

#### 为什么`M`个字符用`M`个字节存储?一个汉字需要用``2-4字节``,那么一个汉字算1个字符还是`2-4`个字符呢?

- `MySQL 5.7`:在该版本中,==**用于指定长度的`M`并不是指定可以容纳的字符的数量**==,**而是用于指定可以容纳的字节数**.因此当`M=20`时就**需要使用`20`个字节来存储数据,而额外的`1`个字节用于存储该数据实际占用的存储空间大小**.在这种情况下由于`utf8mb4`字符集下每个字符都使用`4Bytes`来存储,**因此最多只能存储$\frac{20}{4}=5$个字符**
- `MySQL 8.0`:在该版本中,==**用于指定长度的`M`指定的是该字段能够容纳的字符的数量**==,**一个汉字也算一个字符**,因此当`M=20`时,在`utf8mb4`字符集下,该字段占用的存储空间最多为`80Btyes`.**当然在这样的情况下,就涉及到用于存储某个字段占用的内存字节数的额外的存储空间`+N`的修改问题**

#### ==**那如果使用了变长的`utf8`字符集会如何处理呢?**==

> **在`MySQL 8.0`中是没有变成`utf8`的,在`MySQL`中使用`utf8`等价于使用`utf8mb3`或`utf8mb4`.**

### ==😈待解决== 41 为什么`ENUM`枚举类型占据的存储空间会随元素的个数的增加而增加,并分为`1Bytes|2Bytes`两个阶段?

> 前提:``ENUM``枚举类型最多可以有``65535``个元素

#### `ENUM`枚举类型的底层是实现

##### `枚举`列表与``枚举``哈希表

- 当我们创建表时,我们会设置枚举对象的枚举列表.表创建完成后,我们的表就会自己维护枚举列表对象.我们可以对这个对象进行遍历.

##### 数据表中`ENUM`字段的存储

> 我们向`ENUM`类型字段中存入数据时(以存入字符串为例),并不会直接将该数据存入我们的字段中.而是会存储一个整数类型的索引值,该索引值对应着枚举列表对象的某一个元素.

- 由上面我们知道我们`ENUM`字段中存储的并不是数据本身,而只是一个整数索引值.由于`ENUM`类型最多存储`65535`个元素,因此索引的最大值为`65535`
  - 当我们的元素个数为`1-256`时,最大索引值也只不过为`255`,因此使用`1Bytes`就可以完成索引值的存储,因此此时`ENUM`类型字段只需要占用`1Bytes`的存储空间
    - 当元素个数为`257-65536`时,最小索引值为`256`最大索引值为`65535`,因此必须且只需`2Bytes`用于存储该索引值,因此此时`ENUM`类型字段需要占用`2Bytes`的存储空间

#### 当向表某条记录中的`ENUM`类型字段存入数据时的流程是什么?(以存入字符串为例)

- 系统接收到记录存入请求,并处理到`ENUM`类型字段的存入
- 找到我们该字段对应的枚举列表对象.**遍历该对象**找出我们**存入的数据在枚举列表中的索引**
  - 如果遍历完成后发现**枚举列表中没有我们存入的字段**,那么此次存入**操作会整体失败**,`MySQL`会向用户**报错**
  - 如果遍历时**发现了我们存入的字段**,那么**终止遍历**,并**获取到**该元素在枚举列表中的**索引值**
- **根据找到的索引值存入我们的`ENUM`类型的字段中**.

#### 当查询表记录时`ENUM`类型字段是如何实现正确的呈现的?

> 在呈现时我们的`MySQL`并不会将索引值返回给我们的用户,而是会通过索引值查询到枚举列表中的指定元素后用该元素代替索引值呈现给我们的用户

### 42 为什么`SET`集合类型占据的存储空间会随元素的个数的增加而增加而分成五个阶段?

> **注意**
>
> - `SET`集合类型是具备多选特性的.
> - `SET`集合字段下数据是**不排序**,**其呈现顺序完全由我们定义集合哈希表时的顺序决定**,**不能重复**的,如果存在重复会被自动去重
>   - <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220705161957482.png" alt="image-20220705161957482" style="zoom:60%;" /> <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220705162126964.png" alt="image-20220705162126964" style="zoom:60%;" /><img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220705162249934.png" alt="image-20220705162249934" style="zoom:60%;" />

<img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220705161031035.png" alt="image-20220705161031035" style="zoom:80%;" />

#### 第一阶段

- 此时集合列表中最多有$$8$$个元素.因此其就可以通过`1Bytes`的来存储我们的数据的情况.例如`11010000`就表示集合列表的第1,2,4个元素在我们存入的数据中出现,而剩下5个元素没出现.当集合列表只有4个元素时,我们这个字节的后四个`Bit`就恒全等于0

#### 第二阶段

- 与第一阶段同理,此时集合列表中最少有9个元素,因此使用`1Bytes`不能正确表示,而最大只有16个元素.综合考虑,使用`2Bytes`共`16Bit`是可以正好胜任这一保存任务的

#### 第三阶段

- 与第二阶段同理,此时集合列表中最少有17个元素,因此使用`2Bytes`不能正确表示,而最大只有24个元素.综合考虑,使用`3Bytes`共`24Bit`是可以正好胜任这一保存任务的

#### 第四阶段

- 与第三阶段同理,此时集合列表中最少有25个元素,因此使用`3Bytes`不能正确表示,而最大只有32个元素.综合考虑,使用`4Bytes`共`32Bit`是可以正好胜任这一保存任务的

#### 第五阶段

- 与第三阶段同理,此时集合列表中最少有33个元素,因此使用`4Bytes`不能正确表示,而最大有64个元素.综合考虑,使用`8Bytes`共`64Bit`是可以正好胜任这一保存任务的

#### ==**集合哈希表**==的存储形式

> **作用**:用于==**存入数据时**==实现**快速去重**与**快速生成特定二进制串**
>
> **存储形式**:**一个哈希表**,`HASH值:0/1`在初始时为`HASH:0`

- 是一个哈希表,其在我们创建表时运行到`SET`类型字段的创建时生成的.(以列出了``5个元素``为例)
- 我们可以通过创建时的五个元素的`HASH`哈希值访问到哈希表的对应元素
- 哈希表中元素的取值只有`0/1`两种,且初始时为``0``
- 当我们要生成二进制串时,就可以通过遍历存入元素,以`HASH`值访问该哈希表的副本并将对应值设置为``1``的方式快速完成生成过程

#### ==**集合列表**==的存储形式

> **作用**:用于==**读取数据**==时**快速**地**根据**我们的**二进制串获取**到**原本数据中包含的元素**
>
> **存储形式**:==**一个列表**==,列表中是我们创建表时给`SET`类型指定的元素,并且这些元素是按照我们定义时给出的顺序进行排列的

- 当我们要读取数据时,只需要获取该集合列表的长度`L`,取二进制串的前`L`个`Bit`然后作为`MASK`去对该集合列表进行取值即可

#### 集合哈希表与集合列表结合的快速`SET`类型数据存入

### 43 向`SET`类型字段存入数据的流程

- `MySQL`服务器获取到我们的数据存入语句,并处理到`SET`类型字段的存入
- `MySQL`服务器将我们要存入的数据通过`,`逗号进行划分得到输入的所有元素
- 计算出每一个元素的`HASH`哈希值
- 复制一份该字段的集合哈希表
- 遍历每一个元素,按照元素的`HASH`哈希值访问集合哈希表
  - 如果**访问不到**集合哈希表中的元素,那么该存入操作**整体失败**,`MySQL`会**报错**
  - 如果**访问到了**集合哈希表中的指定元素,那么**将该元素的值设置为``1``**
- 遍历完成后,按**哈希表中的结构化先后顺序**获取到我们集合哈希表中的每一个**键值对的值**组成的**一个序列(长度为``s`)**,并对序列进行**长度补齐操作**
  - 序列长度`<=8`补`8-s`个`0`形成`8Bit`,`1Bytes`的序列
  - 序列长度`(8,16]`补`16-s`个`0`形成`16Bit`,`2Bytes`的序列
  - 序列长度`(16,24]`补``24-s``个`0`形成`24Bit`,`3Bytes`的序列
  - 序列长度`(24,32]`补`32-s`个`0`形成`32Bit`,`4Bytes`的序列
  - 序列长度`(33,64]`补`64-s`个`0`形成`64Bit`,`8Bytes`的序列
- 将我们**计算得到的序列**作为**该字段存入值的代数表示** **存入我们的数据表**

### 44 从`SET`类型字段读出数据的流程

- `MySQL`服务器获取到数据读取的语句,并处理到`SET`类型字段的数据读取
- `MySQL`服务器获取到记录的该字段上的**二进制串**
- 访问对应表的该字段的集合列表**获取到该列表的元素数`L`**,并**对二进制串进行处理**,==**只保留前`L`个`Bit`**
- 以该**处理后的二进制串**为`Boolean`类型的**列表取值序列对我们的集合列表进行取值,**得到**原本数据中出现的元素所组成的列表**.
- 用列表中的元素**组成字符串**,每个元素**在字符串中使用``,``进行分割**
- 如此便**得到**了最终我们需要**呈现给用户的真实值**

### 45 `SET`枚举类型的底层是如何实现的,其集合哈希表会存储到哪里去?是否是以哈希的方式存储其集合哈希表?

### 46 `TEXT`类型与`BLOB`类型的使用

![image-20220703123520246](F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\特殊问题原理解析.assets\image-20220703123520246.png)

### 47 `MySQL`中那些操作指令具备原子性?

### 48 `ALTER ADD`与`ALTER MODIFY`原理的理解

> 以下只是说的形象化理解,不代表是`MySQL`的底层实现

- `ALTER ADD`一般用于给数据表添加字段,添加表级约束等.我们可以这样理解,将创建表时我们给出的用括号包括的字段声明集合理解为一个列表.而`ALTER ADD`指令就是一个可以将语句原封不动地添加到到我们的这个列表中的指令
- `ALTER MODIFY`与`ALTER ADD`类似,他不可以向我们的列表中插入元素,只能对列表中现有的元素进行修改操作.

### ==**49 `AUTO_INCREMENT`自增列**==

> **前提**
>
> - 每一个数据表只能最多设置一个字段为自增长类型
> - 只有被设置为一个`KEY`(`PRIMARY KEY`,`FOREIGN KEY`等)的字段才可以设置为自增长类型
>
> **注意事项**
>
> - **当我们最新的记录的该自增类型字段已经自增到了`10`,此时我们插入一个数据,这个数据指明了该自增字段为`20`,那么我们的数据库就会将其值原封不动地按照`20`保存,并且后续再插入不指定该自增字段的记录时,会从`20`开始自增,而不是`10`**
> - **当存入的记录的该自增类型字段的值为`0`或`NULL`时,等价于没有指定该自增字段的值时.**
> - **当我们最新记录的该字段为`10`,然后我们添加了一个字段值为`-10`的记录,然后再添加一个不指定该字段的记录,那么这个记录的该字段的值为`11`**

- **使用自增类型**

  ```SQL
  
  DROP TABLE IF EXISTS test_auto;
  
  CREATE TABLE test_auto(
  id INT PRIMARY KEY AUTO_INCREMENT,
  last_name VARCHAR(15)
  );
  
  INSERT INTO test_auto(last_name)
  Values
  ('汤凌'),
  ('汤凌凌'),
  ('马婷婷');
  
  INSERT INTO test_auto(id,last_name)
  Values
  (20,'汤汤');
  
  INSERT INTO test_auto(last_name)
  Values
  ('马马婷');
  
  INSERT INTO test_auto(id,last_name)
  Values
  (-1,'马马婷婷');
  
  INSERT INTO test_auto(id,last_name)
  Values
  (-2,'马马婷婷蓉');
  
  INSERT INTO test_auto(last_name)
  Values
  ('汤凌凌凌');
  
  INSERT INTO test_auto(id,last_name)
  Values
  (5,'马马婷婷蓉蓉');
  
  INSERT INTO test_auto(last_name)
  Values
  ('汤汤凌凌凌');
  
  SELECT * FROM test_auto;
  ```

  <img src="F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\03特殊问题原理解析.assets\image-20220705212856855.png" alt="image-20220705212856855" style="zoom:67%;" />

- **数据表创建好后再添加自增类型**

  ```SQL
  ALTER TABLE employees
  MODIFY id INT PRIMARY KEY AUTO_INCREMENT;
  ```

- **数据表创建好后取消指定字段的自增**

  ```SQL
  ALTER TABLE employees
  MODIFY id INT PRIMARY KEY;
  ```

###  ==**50 计算列**==

- ```SQL
  DROP TABLE IF EXISTS TEST;
  CREATE TABLE TEST(
  a INT,
  b INT,
  c INT GENERATED ALWAYS AS (a + b) VIRTUAL
  );
  INSERT INTO TEST(a,b)
  VALUES(50,15);
  
  SELECT *
  FROM TEST; 
  /*
  此时C就是我们的计算列其效果为,我们向表中插入数据时,可以认为表中只有a,b两个字段.而至于字段c,系统会自动根据我们的字段a,b来生产
  */
  
  ```

### 51 自增列`AUTO_INCREMENT`实现自增的内部原理

> **注意**
>
> - 如果我们使用了自增列,那么我们的**数据表中的记录就会自动地实时按照自增列的取值大小进行排序**.因此**使用了自增列的数据表的最后一条记录一定是`AUTO_INCREMENT`自增列取值最大的一列**
> - 无论是`MySQL 8.0`还是`MySQL 5.7`**计数器中的值在服务器运行时都不会以任何方式减少**,而只有增加和不变两种情况
> - **计数器的默认初始值为``1``**

> **前提**:`MySQL`中为每一个带有自增列的表都维护了一个计数器,这个计数器决定了我们的自增列`AUTO_INCREMENT`字段的取值

#### `MySQL 5.7`(自增变量非持久化  )(用时间换空间)

> - `MySQL 5.7`的计数器是只维护在内存上,不维护在磁盘上.因此当`MySQL`服务关闭时,该计数器就会被回收内存,其数据也会直接被清空.当`MySQL`服务重启时,`MySQL`服务器就会读取所有使用了`AUTO_INCREMENT`自增列的表,获取到该表最后一个记录所保存的该字段的值,然后用这个值来初始化该表对应的计数器的值.这样就完成了计数器的回收与重建

- **问题**
  - 我们考虑这样的情况,当我们创建一个表并不给出`AUTO_INCREMENT`自增列地插入5条数据,显然此时`AUTO_INCREMENT`自增列的最后一个记录下的值为5.
  - 然后我们删除掉自增列值为5的记录,此时只有自增列取值分别为`[1,2,3,4]`的四条记录
  - 然后我们再不给出`AUTO_INCREMENT`自增列地插入一条数据,由于计数器的值不会发生减少,因此我们这一条记录的自增列的值为`6`
  - 然后删掉这个记录
  - 重启`MySQL`服务,显然重启后由于计数器的重建方法,此时的计数器的值会被赋值为`4`
  - 因此我们后续再不给出`AUTO_INCREMENT`自增列地插入一条数据,其自增列的值会变为`5`

#### `MySQL 8.0`(自增变量持久化  )(用空间换时间)

> - 不同于`MySQL 5.7`,`MySQL 8.0`不仅在内存上维护计数器,还在磁盘上维护计数器.因此当`MySQL`服务关闭时,首先系统会将当前所有表的计数器的值覆盖存储到磁盘上,然后收回内存上计数器所占据的存储空间.当`MySQL`服务打开时,`MySQL`服务系统就会在磁盘上读取各个表的计数器的值,并以磁盘上保存的值用于给内存上的计数器进行初始化.

- **不同**
  - 由于`MySQL 8.0`的这一改进,就会导致相对于`MySQL 5.7`的重启后会产生自增列为`5`的记录,在`MySQL 8.0`下同样插入一条记录,该记录的自增列的值会是`7`而不是`5`.因为`5|6`都曾经有记录使用过,只不过这两天记录被删除了

#### 由计数器获取自增列取值以及自增列更新的全流程(以前面做示范的实例为例)

- 我们从一张空表开始
- **第一条记录的插入**,首先不带`AUTO_INCREMENT`字段地插入第一条数据,此时计数器为初始值`1`,因此该记录的自增类型字段的值为`1`
- **第二条记录的插入**,然后继续不带`AUTO_INCREMENT`字段地插入第二条数据,此时计数器的初始值为``2``,因此该记录的自增类型字段的值为`2`
- **第三条记录的插入**
  - 然后直接带`AUTO_INCREMENT`字段地插入第三条数据(该记录自增列的值为``20``),直接插入表中(**记录插入**)
  - 然后`MySQL`服务器对数据表做第一次按`AUTO_INCRMENT`列进行排序,此时显然`20`为最大的.因此最后一个记录的自增列值为`20`(**记录排序**)
  - 然后`MySQL`服务器读取数据表的最后一个记录的自增列的值,将``其值+1=20+1=21``赋值为我们的计数器的值(**计数器更新**)
- **第四条记录的插入**,然后不带`AUTO_INCREMENT`字段地插入第四条数据,此时计数器的初始值为`21`,因此这条记录的自增列的值为`21`
- **第五条记录的插入**
  - 然后直接带`AUTO_INCREMENT`字段地插入第五条数据(该记录自增列的值为``-1``),直接插入表中(**记录插入**)
  - 然后`MySQL`服务器对数据表做第一次按`AUTO_INCRMENT`列进行排序,此时显然`21`为最大的.因此最后一个记录的自增列值为`21`(**记录排序**)
  - 然后`MySQL`服务器读取数据表的最后一个记录的自增列的值,将``其值+1=21+1=22``赋值为我们的计数器的值(**计数器更新**)
- **第六条记录的插入**,然后不带`AUTO_INCREMENT`字段地插入第六条数据,此时计数器的初始值为``22``,因此该记录的自增类型字段的值为`22`

### 52 开发中不允许使用外键约束与级联

### 53 `AUTO_INCREMENT`的第一个值一定是1?

### 54 为不同的表指定不同的引擎

> **前提**:设置了外键约束关联起来的表必须使用同一个引擎

### ==**55 使用`CREATE TABLE SELECT`方式创建数据表,原本的约束,数据类型等也会一同被移植?**==

### ==**56 使用`CREATE VIEW AS SELECT`方式创建视图原本的约束,数据类型,触发器等也会一同被移植?**==

### 57 使用`SHOW TABLE STATUS LIKE '<数据表名|视图名>'`查看表或视图的属性信息

### 58 使用`SHOW CREATE TABLE <数据表名>`或`SHOW CREATE VIEW <视图名>`查看表或视图的创建信息

### 59 使用`DESC <视图名|表名>`查看表或视图的各个字段的信息

### 60 视图的哪些增删改会作用到基表,哪些不会?

![image-20220703232059497](F:\A_Java_DataBase_Study_FIle\DataBase\MySQL\特殊问题原理解析.assets\image-20220703232059497.png)

### 61 使用视图创建表的原理以及创建出来的表的特性

### 62 使用`SELECT FROM 数据库名.'数据表名'`实现跨数据库查询

### 63 使用`SHOW CREATE PROCEDURE 存储过程名`或`SHOW CREATE FUNCTION 存储函数名`查看存储过程或存储函数的创建信息

### 64 使用`SHOW PROCEDURE STATUS LIKE '存储过程名'`或`SHOW FUNCTION STATUS LIKE '存储函数名'`查看存储函数或存储过程的简要属性信息

### 65 从`information_schema.Routines`表中查看存储过程与存储函数的详细属性信息

### 66 使用`SELECT * FROM   information_schema.table_constr ins  WHERE table_name='表名'`查看指定表的所有约束

### 67 直接`SELECT @@系统变量名`查看系统变量系统会如何处理呢?

> **前提**
>
> - 我们知道可以用`SELECT @@global.系统变量名`查询全局系统变量
> - 我们还知道可以用`SELECT @@session.系统变量名`查询会话系统变量
> - **`SELECT @@系统变量名`默认先查询会话系统变量列表,若没有再查询系统变量列表**
> - 同理`SHOW [GLOBAL|SESSION] VARIBALES`在不指定是`SESSION|GLOBAL`的情况下会先搜索会话系统变量列表,再搜索全局系统变量列表

### 68 `my.ini`配置文件中包含了我们所有的系统变量(全局的与会话的)?

> **答案**
>
> - `my.ini`配置文件中**只包含了部分系统变量(全局的与会话的)**,如`character_set_client`,`character_set_connection`等

### 全局系统变量与会话系统变量的关系

### 69 `MySQL 8.0`与`MySQL 5.7`系统变量汇总

> - **使用`SHOW GLOBAL VARIABLES;`获取全部全局系统变量**
> - **使用`SHOW SESSION VARIABLES;`获取全部会话系统变量**

### ==**70 涉及到窗口函数时的`SELECT`语句的执行流程**==

### 71 ==**涉及到单行函数在`SELECT`子句中时的执行流程**==

### 72 ==**涉及到聚合函数在``SELECT``子句中时的执行流程**==

### 73 ==**涉及到单行函数在``WHERE|HAVING``子句中时的执行流程**==

### 74 ==**涉及到聚合函数在``WHERE|HAVING``子句中时的执行流程**==

### 75 多表查询的实质与连接归类

### 76 多表查询的小技巧总结

### 77 多表查询+子查询的语句执行顺序问题

#### 内连接

#### 外连接

### 78 单表查询+子查询的语句执行顺序问题

### 79 `NTILE(n)`窗口函数的分组规则

### 80 `NTH_VALUE(expr,n)`的`NULL`数据问题与`LAST_VALUE(expr)`未正确获取预期价值问题

### 81 递归公用表表达式运行流程解析

#### 实例

```mysql
WITH RECURSIVE cte
AS
( 
	SELECT employee_id,last_name,manager_id,1 AS n
    FROM employees WHERE employee_id = 100 -- 种子查询，找到第一代领导

    UNION ALL
	
    SELECT a.employee_id,a.last_name,a.manager_id,n+1
    FROM employees AS a
    JOIN cte ON (a.manager_id = cte.employee_id) -- 递归查询，找出以递归公用表表达式的人为领导的人
)
```

#### 流程解析

- 当调用该递归公用表表达式时，首先执行**种子查询**
  - 种子查询查询得到`employee_id=100`的职工的`employee_id,last_name,manager_id`的基本信息
  - 查询得到的信息在该递归公用表表达式的括号内是可以被随时使用的我们将起结果命名为**虚拟数据表A**
- 然后**第一次执行递归查询**(**执行前``n=1`**)
  - 在`employees`表与`虚拟数据表A`的内连接表中进行查询,该次查询找出了所有**虚拟数据表A**中包括的员工的所有的下属的`employee_id,last_name,manager_id`,我们将这个结果命名为**虚拟数据表B**
- 对**虚拟数据表A**与**虚拟数据表B**执行`UNION ALL`拼接操作得到**虚拟数据表C**(**执行前`n=2`**)
- 然后进行**第二次递归查询**( **执行前`n=2`**)
  - 在`employees`表与`虚拟数据表C`的内连接表中进行查询,该次查询找出了所有**虚拟数据表C**中包括的员工的所有的下属的`employee_id,last_name,manager_id`,我们将这个结果命名为**虚拟数据表D**
- 对**虚拟数据表C**与**虚拟数据表D**执行`UNION ALL`拼接操作得到**虚拟数据表E**(**执行前`n=3`**)
- 然后进行**第三次递归查询**(**执行前`n=3`**)
  - 在`employees`表与`虚拟数据表E`的内连接表中进行查询,该次查询找出了所有**虚拟数据表E**中包括的员工的所有的下属的`employee_id,last_name,manager_id`,我们将这个结果命名为**虚拟数据表F**
- 对**虚拟数据表E**与**虚拟数据表F**执行`UNION ALL`拼接操作得到**虚拟数据表G**(**执行前`n=4`**)
- **依次类推**

#### 作用解析

- **虚拟数据表A**中只包括`employee_id=100`的员工,也即只有一条记录
- **虚拟数据表C**中在**虚拟数据表A**的基础上多出了以`employee_id=100`的员工为上司的员工的记录
- **虚拟数据表E**中在**虚拟数据表C**的基础上多出了以**虚拟数据表C**中`employee_id=100`的员工的下属为上司的员工的记录
- **虚拟数据表G**中在**虚拟数据表E**的基础上多出了以**虚拟数据表E**中`employee_id=100`的员工的所有下属的所有下属为上司的员工的记录

## `EXISTS|NOT EXISTS`的运行原理以及其与`IN|NOT IN`的区别
